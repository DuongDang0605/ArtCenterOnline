using System.Globalization;
using ArtCenterOnline.Server.Data;
using ArtCenterOnline.Server.Model;
using ArtCenterOnline.Server.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[ApiController]
[Route("api/[controller]")]
[Authorize] // yêu cầu đăng nhập
public class ClassSessionsController : ControllerBase
{
    private readonly AppDbContext _db;
    private readonly ClassSessionMonthlySyncService _sync;

    public ClassSessionsController(AppDbContext db, ClassSessionMonthlySyncService sync)
    {
        _db = db;
        _sync = sync;
    }

    private static string D(DateOnly d) => d.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    private static string T(TimeSpan t) => t.ToString(@"hh\:mm", CultureInfo.InvariantCulture);

    [HttpGet("all")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> GetAll(
        [FromQuery] string from,
        [FromQuery] string to,
        [FromQuery] int? classId,
        [FromQuery] int? teacherId,
        [FromQuery] int? status,
        CancellationToken ct)
    {
        if (!DateOnly.TryParseExact(from, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var fromDate) ||
            !DateOnly.TryParseExact(to, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var toDate))
            return BadRequest("from/to must be yyyy-MM-dd.");

        var q = _db.ClassSessions
            .AsNoTracking()
            .Include(s => s.Class)
            .Include(s => s.Teacher)
            .Where(s => s.SessionDate >= fromDate && s.SessionDate <= toDate);

        if (classId.HasValue) q = q.Where(s => s.ClassID == classId.Value);
        if (teacherId.HasValue) q = q.Where(s => s.TeacherId == teacherId.Value);
        if (status.HasValue) q = q.Where(s => (int)s.Status == status.Value);

        var items = await q
            .OrderBy(s => s.SessionDate)
            .ThenBy(s => s.StartTime)
            .Select(s => new
            {
                sessionId = s.SessionId,
                classId = s.ClassID,
                className = s.Class != null ? s.Class.ClassName : "(N/A)",
                sessionDate = D(s.SessionDate),
                startTime = T(s.StartTime),
                endTime = T(s.EndTime),
                note = s.Note,
                status = (int)s.Status,
                isAutoGenerated = s.IsAutoGenerated,
                teacherId = s.TeacherId,
                teacherName = s.Teacher != null
                    ? s.Teacher.TeacherName
                    : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null)
            })
            .ToListAsync(ct);

        return Ok(items);
    }

    [HttpGet("~/api/Sessions/all")]
    [Authorize(Roles = "Admin,Teacher")]
    public Task<IActionResult> GetAllCompat(
        [FromQuery] string from, [FromQuery] string to,
        [FromQuery] int? classId, [FromQuery] int? teacherId, [FromQuery] int? status,
        CancellationToken ct) => GetAll(from, to, classId, teacherId, status, ct);

    [HttpGet]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> List(
        [FromQuery] int classId,
        [FromQuery] string from,
        [FromQuery] string to,
        CancellationToken ct)
    {
        if (classId <= 0) return BadRequest("classId is required.");
        if (!DateOnly.TryParseExact(from, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var fromDate) ||
            !DateOnly.TryParseExact(to, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var toDate))
            return BadRequest("from/to must be yyyy-MM-dd.");

        var items = await _db.ClassSessions
            .AsNoTracking()
            .Include(s => s.Class)
            .Include(s => s.Teacher)
            .Where(s => s.ClassID == classId && s.SessionDate >= fromDate && s.SessionDate <= toDate)
            .OrderBy(s => s.SessionDate).ThenBy(s => s.StartTime)
            .Select(s => new
            {
                s.SessionId,
                s.ClassID,
                sessionDate = D(s.SessionDate),
                startTime = T(s.StartTime),
                endTime = T(s.EndTime),
                s.Note,
                status = (int)s.Status,
                s.IsAutoGenerated,
                s.TeacherId,
                teacherName = s.Teacher != null
                    ? s.Teacher.TeacherName
                    : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null)
            })
            .ToListAsync(ct);

        return Ok(items);
    }

    [HttpGet("{sessionId:int}")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> GetOne([FromRoute] int sessionId, CancellationToken ct)
    {
        var s = await _db.ClassSessions
            .AsNoTracking()
            .Include(x => x.Class)
            .Include(x => x.Teacher)
            .FirstOrDefaultAsync(x => x.SessionId == sessionId, ct);

        if (s == null) return NotFound();

        var startLocal = new DateTime(
            s.SessionDate.Year, s.SessionDate.Month, s.SessionDate.Day,
            s.StartTime.Hours, s.StartTime.Minutes, s.StartTime.Seconds,
            DateTimeKind.Local
        );
        var canEdit = DateTime.Now < startLocal;

        return Ok(new
        {
            s.SessionId,
            s.ClassID,
            className = s.Class != null ? s.Class.ClassName : "(N/A)",
            sessionDate = D(s.SessionDate),
            startTime = T(s.StartTime),
            endTime = T(s.EndTime),
            s.Note,
            status = (int)s.Status,
            s.IsAutoGenerated,
            s.TeacherId,
            teacherName = s.Teacher != null
                ? s.Teacher.TeacherName
                : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null),
            mainTeacherId = s.Class?.MainTeacherId,
            canEdit
        });
    }

    public record UpdateSessionDto(string? SessionDate, TimeSpan? StartTime, TimeSpan? EndTime, int? TeacherId, string? Note, int? Status);

    [HttpPatch("{sessionId:int}")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> UpdateSession([FromRoute] int sessionId, [FromBody] UpdateSessionDto dto, CancellationToken ct)
    {
        var s = await _db.ClassSessions.Include(x => x.Class).FirstOrDefaultAsync(x => x.SessionId == sessionId, ct);
        if (s == null) return NotFound();

        var originalStartLocal = new DateTime(
            s.SessionDate.Year, s.SessionDate.Month, s.SessionDate.Day,
            s.StartTime.Hours, s.StartTime.Minutes, s.StartTime.Seconds,
            DateTimeKind.Local
        );
        if (DateTime.Now >= originalStartLocal)
            return Conflict("Buổi học đã bắt đầu/đã diễn ra, không thể đổi giáo viên/đổi lịch.");

        var newDate = s.SessionDate;
        if (!string.IsNullOrWhiteSpace(dto.SessionDate))
        {
            if (!DateOnly.TryParseExact(dto.SessionDate, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var parsed))
                return BadRequest("SessionDate phải có dạng yyyy-MM-dd.");
            newDate = parsed;
        }

        var newStart = dto.StartTime ?? s.StartTime;
        var newEnd = dto.EndTime ?? s.EndTime;
        if (newEnd <= newStart) return BadRequest("EndTime must be greater than StartTime.");

        var duplicate = await _db.ClassSessions.AnyAsync(x =>
            x.ClassID == s.ClassID && x.SessionDate == newDate && x.StartTime == newStart && x.SessionId != s.SessionId, ct);
        if (duplicate) return Conflict("Đã tồn tại buổi khác của lớp với cùng ngày/giờ bắt đầu.");

        var effectiveTeacher = dto.TeacherId ?? s.TeacherId ?? s.Class?.MainTeacherId;
        if (effectiveTeacher.HasValue)
        {
            var overlap = await _sync.CheckTeacherOverlapAsync(effectiveTeacher.Value, s.ClassID, newDate, newStart, newEnd, s.SessionId, ct);
            if (overlap) return Conflict("Giáo viên đã có buổi trùng giờ.");
        }

        if (dto.Status.HasValue)
        {
            var val = dto.Status.Value;
            if (!Enum.IsDefined(typeof(SessionStatus), val))
                return BadRequest("Status không hợp lệ.");
            if (val == (int)SessionStatus.Cancelled && DateTime.Now >= originalStartLocal)
                return Conflict("Buổi đã/đang diễn ra, không thể hủy.");
            s.Status = (SessionStatus)val;
        }

        s.SessionDate = newDate;
        s.StartTime = newStart;
        s.EndTime = newEnd;
        s.TeacherId = dto.TeacherId;
        if (dto.Note != null) s.Note = dto.Note;
        s.IsAutoGenerated = false;

        await _db.SaveChangesAsync(ct);
        return NoContent();
    }

    [HttpPost("sync-month/{classId:int}")]
    [Authorize(Policy = "AdminOnly")]
    public async Task<IActionResult> SyncMonth([FromRoute] int classId, [FromQuery] int? year, [FromQuery] int? month, CancellationToken ct)
    {
        var result = await _sync.SyncMonthAsync(classId, year, month, ct);
        return Ok(result);
    }
}

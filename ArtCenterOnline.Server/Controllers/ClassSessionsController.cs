// Controllers/ClassSessionsController.cs
using ArtCenterOnline.Server.Data;
using ArtCenterOnline.Server.Model;
using ArtCenterOnline.Server.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Globalization;

#nullable enable

[ApiController]
[Route("api/[controller]")]
[Authorize] // yêu cầu đăng nhập
public class ClassSessionsController : ControllerBase
{
    private readonly AppDbContext _db;
    private readonly IStudentScheduleValidator _studentValidator;

    // constructor hiện có:
    public ClassSessionsController(AppDbContext db, IStudentScheduleValidator studentValidator)
    {
        _db = db;
        _studentValidator = studentValidator;
    }


    // Helpers hiển thị
    private static string D(DateOnly d) => d.ToString("dd/MM/yyyy", CultureInfo.InvariantCulture);
    private static string T(TimeSpan t) => t.ToString(@"hh\:mm", CultureInfo.InvariantCulture);

    // -------------------- LIST TỔNG HỢP --------------------
    [HttpGet("all")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> GetAll(
        [FromQuery] string from,
        [FromQuery] string to,
        [FromQuery] int? classId,
        [FromQuery] int? teacherId,
        [FromQuery] int? status,
        CancellationToken ct)
    {
        if (!DateOnly.TryParseExact(from, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var fromDate) ||
            !DateOnly.TryParseExact(to, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var toDate))
            return BadRequest(new { message = "from/to phải có dạng yyyy-MM-dd." });

        var q = _db.ClassSessions
            .AsNoTracking()
            .Include(s => s.Class)
            .Include(s => s.Teacher)
            .Where(s => s.SessionDate >= fromDate && s.SessionDate <= toDate);

        if (classId.HasValue) q = q.Where(s => s.ClassID == classId.Value);
        if (teacherId.HasValue) q = q.Where(s => s.TeacherId == teacherId.Value);
        if (status.HasValue) q = q.Where(s => (int)s.Status == status.Value);

        var items = await q
            .OrderBy(s => s.SessionDate)
            .ThenBy(s => s.StartTime)
            .Select(s => new
            {
                sessionId = s.SessionId,
                classId = s.ClassID,
                className = s.Class != null ? s.Class.ClassName : $"ID {s.ClassID}",
                sessionDate = s.SessionDate.ToString("yyyy-MM-dd"),
                startTime = s.StartTime.ToString(@"hh\:mm"),
                endTime = s.EndTime.ToString(@"hh\:mm"),
                note = s.Note,
                status = (int)s.Status,
                isAutoGenerated = s.IsAutoGenerated,
                teacherId = s.TeacherId,
                teacherName = s.Teacher != null
                    ? s.Teacher.TeacherName
                    : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null)
            })
            .ToListAsync(ct);

        return Ok(items);
    }

    // alias cũ
    [HttpGet("~/api/Sessions/all")]
    [Authorize(Roles = "Admin,Teacher")]
    public Task<IActionResult> GetAllCompat(
        [FromQuery] string from, [FromQuery] string to,
        [FromQuery] int? classId, [FromQuery] int? teacherId, [FromQuery] int? status,
        CancellationToken ct) => GetAll(from, to, classId, teacherId, status, ct);

    // -------------------- LIST THEO LỚP --------------------
    [HttpGet]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> List(
        [FromQuery] int classId,
        [FromQuery] string from,
        [FromQuery] string to,
        CancellationToken ct)
    {
        if (classId <= 0) return BadRequest(new { message = "classId là bắt buộc." });
        if (!DateOnly.TryParseExact(from, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var fromDate) ||
            !DateOnly.TryParseExact(to, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var toDate))
            return BadRequest(new { message = "from/to phải có dạng yyyy-MM-dd." });

        var items = await _db.ClassSessions
            .AsNoTracking()
            .Include(s => s.Class)
            .Include(s => s.Teacher)
            .Where(s => s.ClassID == classId && s.SessionDate >= fromDate && s.SessionDate <= toDate)
            .OrderBy(s => s.SessionDate).ThenBy(s => s.StartTime)
            .Select(s => new
            {
                s.SessionId,
                s.ClassID,
                sessionDate = s.SessionDate.ToString("yyyy-MM-dd"),
                startTime = s.StartTime.ToString(@"hh\:mm"),
                endTime = s.EndTime.ToString(@"hh\:mm"),
                s.Note,
                status = (int)s.Status,
                s.IsAutoGenerated,
                s.TeacherId,
                teacherName = s.Teacher != null
                    ? s.Teacher.TeacherName
                    : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null)
            })
            .ToListAsync(ct);

        return Ok(items);
    }

    // -------------------- LẤY 1 BUỔI --------------------
    [HttpGet("{sessionId:int}")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> GetOne([FromRoute] int sessionId, CancellationToken ct)
    {
        var s = await _db.ClassSessions
            .AsNoTracking()
            .Include(x => x.Class)
            .Include(x => x.Teacher)
            .FirstOrDefaultAsync(x => x.SessionId == sessionId, ct);

        if (s == null) return NotFound();

        // Cho FE biết còn được sửa không
        var startLocal = new DateTime(
            s.SessionDate.Year, s.SessionDate.Month, s.SessionDate.Day,
            s.StartTime.Hours, s.StartTime.Minutes, 0, DateTimeKind.Local);
        var canEdit = DateTime.Now < startLocal;

        return Ok(new
        {
            s.SessionId,
            s.ClassID,
            className = s.Class != null ? s.Class.ClassName : $"ID {s.ClassID}",
            sessionDate = s.SessionDate.ToString("yyyy-MM-dd"),
            startTime = s.StartTime.ToString(@"hh\:mm"),
            endTime = s.EndTime.ToString(@"hh\:mm"),
            s.Note,
            status = (int)s.Status,
            s.IsAutoGenerated,
            s.TeacherId,
            teacherName = s.Teacher != null
                ? s.Teacher.TeacherName
                : (s.Class != null && s.Class.MainTeacher != null ? s.Class.MainTeacher.TeacherName : null),
            mainTeacherId = s.Class?.MainTeacherId,
            canEdit
        });
    }
   


    // -------------------- UPDATE/PATCH 1 BUỔI --------------------
    public record UpdateSessionDto(string? SessionDate, TimeSpan? StartTime, TimeSpan? EndTime, int? TeacherId, string? Note, int? Status);

    [HttpPatch("{sessionId:int}")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> UpdateSession([FromRoute] int sessionId, [FromBody] UpdateSessionDto dto, CancellationToken ct)
    {
        var s = await _db.ClassSessions
            .Include(x => x.Class)
            .FirstOrDefaultAsync(x => x.SessionId == sessionId, ct);
        if (s == null) return NotFound(new { message = "Buổi học không tồn tại." });

        // Không cho sửa nếu đã/đang diễn ra (theo giờ cũ)
        var originalStartLocal = new DateTime(
            s.SessionDate.Year, s.SessionDate.Month, s.SessionDate.Day,
            s.StartTime.Hours, s.StartTime.Minutes, 0, DateTimeKind.Local);
        if (DateTime.Now >= originalStartLocal)
            return Conflict(new { message = $"Buổi {s.SessionDate:dd/MM/yyyy} {s.StartTime:hh\\:mm} đã/đang diễn ra, không thể chỉnh sửa." });

        // Lấy giá trị mới
        var newDate = s.SessionDate;
        if (!string.IsNullOrWhiteSpace(dto.SessionDate))
        {
            if (!DateOnly.TryParse(dto.SessionDate, out var parsed))
                return BadRequest(new { message = "SessionDate phải có dạng yyyy-MM-dd." });
            newDate = parsed;
        }
        var newStart = dto.StartTime ?? s.StartTime;
        var newEnd = dto.EndTime ?? s.EndTime;
        if (newEnd <= newStart) return BadRequest(new { message = "Giờ kết thúc phải lớn hơn giờ bắt đầu." });

        // 1) Trùng KEY trong CÙNG LỚP (ClassID + Date + StartTime)
        var dup = await _db.ClassSessions
            .Include(x => x.Class)
            .Where(x => x.ClassID == s.ClassID
                     && x.SessionDate == newDate
                     && x.SessionId != s.SessionId
                     && x.StartTime == newStart)
            .Select(x => new { x.ClassID, ClassName = x.Class != null ? x.Class.ClassName : $"ID {x.ClassID}" })
            .FirstOrDefaultAsync(ct);
        if (dup != null)
            return Conflict(new { message = $"Đã tồn tại buổi khác của lớp {dup.ClassName} vào {newDate:dd/MM/yyyy} lúc {newStart:hh\\:mm}." });

        // 2) Giáo viên (mới/hiệu lực) có bận buổi khác cùng NGÀY & chồng giờ?
        //    Lưu ý: giáo viên thực sự của 1 buổi là TeacherId (nếu có) NGƯỢC LẠI dùng Class.MainTeacherId
        var effectiveTeacher = dto.TeacherId ?? s.TeacherId ?? s.Class?.MainTeacherId;
        if (effectiveTeacher.HasValue)
        {
            var clash = await _db.ClassSessions
                .Include(x => x.Class)
                .Where(x =>
                    x.SessionId != s.SessionId &&
                    x.SessionDate == newDate &&
                    (
                        (x.TeacherId != null && x.TeacherId == effectiveTeacher.Value) ||
                        (x.TeacherId == null && x.Class!.MainTeacherId == effectiveTeacher.Value)
                    ) &&
                    // overlap: A.start < B.end && B.start < A.end
                    newStart < x.EndTime && x.StartTime < newEnd)
                .Select(x => new
                {
                    x.SessionDate,
                    x.StartTime,
                    x.EndTime,
                    ClassName = x.Class != null ? x.Class.ClassName : $"ID {x.ClassID}"
                })
                .FirstOrDefaultAsync(ct);

            if (clash != null)
            {
                var who = effectiveTeacher.Value == (s.TeacherId ?? s.Class?.MainTeacherId)
                    ? "Giáo viên"
                    : "Giáo viên mới";
                return Conflict(new
                {
                    message = $"{who} đang bận {clash.SessionDate:dd/MM/yyyy} {clash.StartTime:hh\\:mm}-{clash.EndTime:hh\\:mm} tại lớp {clash.ClassName}. " +
                              $"Không thể đổi sang {newDate:dd/MM/yyyy} {newStart:hh\\:mm}-{newEnd:hh\\:mm}."
                });
            }
        }

        // 3) (tùy chọn) Không cho sửa sang quá khứ — bật nếu cần
        // var newStartLocal = new DateTime(newDate.Year, newDate.Month, newDate.Day, newStart.Hours, newStart.Minutes, 0, DateTimeKind.Local);
        // if (DateTime.Now >= newStartLocal) return Conflict(new { message = "Không thể sửa sang thời điểm đã qua." });

        // Áp dụng cập nhật
        s.SessionDate = newDate;
        s.StartTime = newStart;
        s.EndTime = newEnd;
        s.TeacherId = dto.TeacherId;          // có thể null → UI sẽ fallback GV chính
        if (dto.Note != null) s.Note = dto.Note;
        if (dto.Status.HasValue)
        {
            var val = dto.Status.Value;
            if (!Enum.IsDefined(typeof(SessionStatus), val))
                return BadRequest(new { message = "Status không hợp lệ." });
            s.Status = (SessionStatus)val;
        }
        // mọi chỉnh sửa đều trở thành thủ công
        s.IsAutoGenerated = false;

        await _db.SaveChangesAsync(ct);
        return NoContent();
    }
    // -------------------- PREFLIGHT: Cảnh báo trùng HS theo BUỔI --------------------
    [HttpPost("{sessionId:int}/check-student-overlap")]
    [Authorize(Roles = "Admin,Teacher")]
    public async Task<IActionResult> CheckStudentOverlapForSession(
        [FromRoute] int sessionId,
        [FromBody] UpdateSessionDto? dto,
        CancellationToken ct)
    {
        var s = await _db.ClassSessions
            .Include(x => x.Class)
            .FirstOrDefaultAsync(x => x.SessionId == sessionId, ct);
        if (s == null) return NotFound(new { message = "Buổi học không tồn tại." });

        // Lấy giá trị dự kiến sau chỉnh
        var newDate = s.SessionDate;
        if (!string.IsNullOrWhiteSpace(dto?.SessionDate))
        {
            if (!DateOnly.TryParse(dto!.SessionDate, out var parsed))
                return BadRequest(new { message = "SessionDate phải có dạng yyyy-MM-dd." });
            newDate = parsed;
        }
        var newStart = dto?.StartTime ?? s.StartTime;
        var newEnd = dto?.EndTime ?? s.EndTime;
        if (newEnd <= newStart) return BadRequest(new { message = "Giờ kết thúc phải lớn hơn giờ bắt đầu." });

        var warnings = await _studentValidator.CheckForSessionAsync(
            s.ClassID, newDate, newStart, newEnd, sessionId, ct);

        // Trả về mảng chuỗi cảnh báo; rỗng nếu không có xung đột
        return Ok(warnings);
    }

    // -------------------- SYNC THÁNG --------------------
    [HttpPost("sync-month/{classId:int}")]
    [Authorize(Policy = "AdminOnly")]
    public async Task<IActionResult> SyncMonth([FromRoute] int classId, [FromQuery] int? year, [FromQuery] int? month, CancellationToken ct)
    {
        // giữ nguyên dịch vụ sync hiện có
        var sync = HttpContext.RequestServices.GetRequiredService<ClassSessionMonthlySyncService>();
        var result = await sync.SyncMonthAsync(classId, year, month, ct);
        return Ok(result);
    }
}

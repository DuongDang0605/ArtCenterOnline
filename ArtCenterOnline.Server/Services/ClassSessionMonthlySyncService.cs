using ArtCenterOnline.Server.Data;
using ArtCenterOnline.Server.Model;
using Microsoft.EntityFrameworkCore;
using System.Globalization;

namespace ArtCenterOnline.Server.Services
{
    public class ClassSessionMonthlySyncService
    {
        private readonly AppDbContext _db;
        public ClassSessionMonthlySyncService(AppDbContext db) => _db = db;

        public record SyncResult(int Created, int Updated, int Deleted, int SkippedTeacherConflicts);

        public async Task<SyncResult> SyncMonthAsync(int classId, int? year = null, int? month = null, CancellationToken ct = default)
        {
            var today = DateOnly.FromDateTime(DateTime.UtcNow.Date);
            var now = DateTime.UtcNow;

            var cls = await _db.Classes.Include(c => c.Schedules).FirstOrDefaultAsync(c => c.ClassID == classId, ct);
            if (cls == null) throw new ArgumentException("Class not found");

            var activeSchedules = cls.Schedules.Where(s => s.IsActive).ToList();
            if (!activeSchedules.Any()) return new SyncResult(0, 0, 0, 0);

            var y = year ?? today.Year;
            var m = month ?? today.Month;
            var firstOfMonth = new DateOnly(y, m, 1);
            var lastOfMonth = firstOfMonth.AddMonths(1).AddDays(-1);
            var from = today > firstOfMonth ? today : firstOfMonth;
            var to = lastOfMonth;

            var targets = new List<(DateOnly d, TimeSpan start, TimeSpan end, string? note)>();
            for (var d = from; d <= to; d = d.AddDays(1))
            {
                var dow = d.DayOfWeek;
                foreach (var s in activeSchedules.Where(s => s.DayOfWeek == dow))
                {
                    if (s.EndTime <= s.StartTime)
                        throw new InvalidOperationException("Schedule invalid: EndTime must be > StartTime");
                    targets.Add((d, s.StartTime, s.EndTime, s.Note));
                }
            }

            // Validate: < 5 sessions per ISO week
            var weekGroups = targets.GroupBy(t =>
            {
                var dt = new DateTime(t.d.Year, t.d.Month, t.d.Day);
                return ISOWeek.GetYear(dt) * 100 + ISOWeek.GetWeekOfYear(dt);
            });
            if (weekGroups.Any(g => g.Count() > 5))
                throw new InvalidOperationException("Vượt quá 5 buổi/tuần trong tháng hiện tại.");

            int created = 0, updated = 0, deleted = 0, teacherConflicts = 0;

            var futureSessions = await _db.ClassSessions
                .Include(s => s.Class)
                .Where(s => s.ClassID == classId && s.SessionDate >= from && s.SessionDate <= to)
                .ToListAsync(ct);

            var map = futureSessions.ToDictionary(x => (x.SessionDate, x.StartTime), x => x);

            foreach (var t in targets)
            {
                if (map.TryGetValue((t.d, t.start), out var existing))
                {
                    if (existing.IsAutoGenerated)
                    {
                        if (existing.EndTime != t.end || existing.Note != t.note)
                        {
                            var effectiveTeacherId = existing.TeacherId ?? cls.MainTeacherId;
                            if (effectiveTeacherId.HasValue &&
                                await CheckTeacherOverlapAsync(effectiveTeacherId.Value, classId, existing.SessionDate, t.start, t.end, existing.SessionId, ct))
                            {
                                teacherConflicts++; continue;
                            }
                            existing.EndTime = t.end;
                            existing.Note = t.note;
                            updated++;
                        }
                    }
                }
                else
                {
                    var effectiveTeacherId = cls.MainTeacherId;
                    if (effectiveTeacherId.HasValue &&
                        await CheckTeacherOverlapAsync(effectiveTeacherId.Value, classId, t.d, t.start, t.end, null, ct))
                    {
                        teacherConflicts++; continue;
                    }

                    _db.ClassSessions.Add(new ClassSession
                    {
                        ClassID = classId,
                        TeacherId = null,
                        SessionDate = t.d,
                        StartTime = t.start,
                        EndTime = t.end,
                        Note = t.note,
                        Status = SessionStatus.Planned,
                        IsAutoGenerated = true,
                        CreatedAt = now
                    });
                    created++;
                }
            }

            var targetKeys = targets.Select(tt => (tt.d, tt.start)).ToHashSet();
            var toRemove = futureSessions
                .Where(s => s.IsAutoGenerated && !targetKeys.Contains((s.SessionDate, s.StartTime)))
                .ToList();

            if (toRemove.Count > 0)
            {
                _db.ClassSessions.RemoveRange(toRemove);
                deleted += toRemove.Count;
            }

            if (created + updated + deleted > 0)
                await _db.SaveChangesAsync(ct);

            return new SyncResult(created, updated, deleted, teacherConflicts);
        }

        public async Task<bool> CheckTeacherOverlapAsync(int teacherId, int currentClassId, DateOnly date, TimeSpan start, TimeSpan end, int? excludeSessionId, CancellationToken ct)
        {
            bool Overlaps(TimeSpan a1, TimeSpan a2, TimeSpan b1, TimeSpan b2) => a1 < b2 && b1 < a2;

            var q1 = _db.ClassSessions
                .Include(s => s.Class)
                .Where(s => s.SessionDate == date && s.TeacherId == teacherId && (excludeSessionId == null || s.SessionId != excludeSessionId.Value));

            var q2 = _db.ClassSessions
                .Include(s => s.Class)
                .Where(s => s.SessionDate == date && s.TeacherId == null && s.Class!.MainTeacherId == teacherId && (excludeSessionId == null || s.SessionId != excludeSessionId.Value));

            var list = await q1.Concat(q2).ToListAsync(ct);
            foreach (var x in list)
            {
                if (x.ClassID == currentClassId && excludeSessionId == null && x.StartTime == start) continue;
                if (Overlaps(x.StartTime, x.EndTime, start, end)) return true;
            }
            return false;
        }
    }
}

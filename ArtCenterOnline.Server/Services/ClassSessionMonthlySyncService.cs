using ArtCenterOnline.Server.Data;
using ArtCenterOnline.Server.Model;
using Microsoft.EntityFrameworkCore;
using System.Globalization;

namespace ArtCenterOnline.Server.Services
{
    public class ClassSessionMonthlySyncService
    {
        private readonly AppDbContext _db;
        public ClassSessionMonthlySyncService(AppDbContext db) => _db = db;

        public record SyncResult(int Created, int Updated, int Deleted, int SkippedTeacherConflicts);

        public async Task<SyncResult> SyncMonthAsync(int classId, int? year = null, int? month = null, CancellationToken ct = default)
        {
            var clss = await _db.Classes.AsNoTracking().FirstOrDefaultAsync(c => c.ClassID == classId, ct);
            if (clss == null) throw new InvalidOperationException($"Không tìm thấy lớp #{classId}.");
            if (clss.Status != 1) return new SyncResult(0, 0, 0, 0); // lớp không active → bỏ qua

            var today = DateOnly.FromDateTime(DateTime.UtcNow.Date);
            var now = DateTime.UtcNow;

            var cls = await _db.Classes
                .Include(c => c.Schedules)
                .FirstOrDefaultAsync(c => c.ClassID == classId, ct);
            if (cls == null) throw new ArgumentException("Class not found");

            var activeSchedules = cls.Schedules.Where(s => s.IsActive).ToList();
            if (!activeSchedules.Any()) return new SyncResult(0, 0, 0, 0);

            var y = year ?? today.Year;
            var m = month ?? today.Month;
            var firstOfMonth = new DateOnly(y, m, 1);
            var lastOfMonth = firstOfMonth.AddMonths(1).AddDays(-1);

            // Không backfill/hồi tố ngày đã qua trong tháng
            var from = today > firstOfMonth ? today : firstOfMonth;
            var to = lastOfMonth;

            // targets gồm cả teacherId từ Schedule
            var targets = new List<(DateOnly d, TimeSpan start, TimeSpan end, string? note, int? teacherId)>();
            for (var d = from; d <= to; d = d.AddDays(1))
            {
                var dow = d.DayOfWeek;
                foreach (var s in activeSchedules.Where(s => s.DayOfWeek == dow))
                {
                    if (s.EndTime <= s.StartTime)
                        throw new InvalidOperationException("Schedule invalid: EndTime must be > StartTime");

                    targets.Add((d, s.StartTime, s.EndTime, s.Note, s.TeacherId));
                }
            }

            // Validate: < 5 sessions per ISO week
            var weekGroups = targets.GroupBy(t =>
            {
                var dt = new DateTime(t.d.Year, t.d.Month, t.d.Day);
                return ISOWeek.GetYear(dt) * 100 + ISOWeek.GetWeekOfYear(dt);
            });
            if (weekGroups.Any(g => g.Count() > 5))
                throw new InvalidOperationException("Vượt quá 5 buổi/tuần trong tháng hiện tại.");

            int created = 0, updated = 0, deleted = 0, teacherConflicts = 0;

            var futureSessions = await _db.ClassSessions
                .Where(s => s.ClassID == classId && s.SessionDate >= from && s.SessionDate <= to)
                .ToListAsync(ct);

            // Map theo (date, startTime) để tìm "cùng slot"
            var map = futureSessions.ToDictionary(x => (x.SessionDate, x.StartTime), x => x);

            foreach (var tt in targets)
            {
                if (map.TryGetValue((tt.d, tt.start), out var existing))
                {
                    // Đẩy thay đổi xuống các buổi tự sinh còn "mở"
                    if (existing.IsAutoGenerated)
                    {
                        // "Khoá" tối thiểu: Planned + chưa có attendance
                        bool hasAttendance = await _db.Attendances.AnyAsync(a => a.SessionId == existing.SessionId, ct);
                        bool canAutoUpdate = existing.Status == SessionStatus.Planned && !hasAttendance;

                        if (canAutoUpdate)
                        {
                            // Nếu lịch có chỉ định GV mới → kiểm tra trùng trước khi set
                            if (tt.teacherId.HasValue)
                            {
                                var willChangeTeacher = existing.TeacherId != tt.teacherId;
                                if (willChangeTeacher)
                                {
                                    if (await CheckTeacherOverlapAsync(tt.teacherId.Value, classId, existing.SessionDate, tt.start, tt.end, existing.SessionId, ct))
                                    {
                                        teacherConflicts++;
                                        continue; // bỏ qua cập nhật buổi này vì trùng GV
                                    }
                                    existing.TeacherId = tt.teacherId;
                                }
                            }
                            else
                            {
                                // Lịch không có GV → set null (tạm thời cho tới khi siết NOT NULL)
                                if (existing.TeacherId != null)
                                    existing.TeacherId = null;
                            }

                            // Cập nhật phần còn lại
                            if (existing.EndTime != tt.end) existing.EndTime = tt.end;
                            if (existing.StartTime != tt.start) existing.StartTime = tt.start; // nếu thay giờ bắt đầu ngay slot này
                            if (existing.Note != tt.note) existing.Note = tt.note;

                            updated++;
                        }
                        // else: buổi đã khoá → bỏ qua
                    }
                }
                else
                {
                    // Tạo mới: dùng teacherId từ Schedule (không fallback MainTeacherId)
                    if (tt.teacherId.HasValue)
                    {
                        // Kiểm tra trùng GV trước khi tạo
                        if (await CheckTeacherOverlapAsync(tt.teacherId.Value, classId, tt.d, tt.start, tt.end, null, ct))
                        {
                            teacherConflicts++;
                            continue; // bỏ qua buổi này vì trùng GV
                        }
                    }

                    _db.ClassSessions.Add(new ClassSession
                    {
                        ClassID = classId,
                        TeacherId = tt.teacherId,             // CHỈ dùng từ Schedule
                        SessionDate = tt.d,
                        StartTime = tt.start,
                        EndTime = tt.end,
                        Note = tt.note,
                        Status = SessionStatus.Planned,
                        IsAutoGenerated = true,
                        CreatedAt = now
                    });
                    created++;
                }
            }

            // Xoá các buổi auto-generated không còn trong targets
            var targetKeys = targets.Select(t => (t.d, t.start)).ToHashSet();
            var toRemove = futureSessions
                .Where(s => s.IsAutoGenerated && !targetKeys.Contains((s.SessionDate, s.StartTime)))
                .ToList();

            if (toRemove.Count > 0)
            {
                _db.ClassSessions.RemoveRange(toRemove);
                deleted += toRemove.Count;
            }

            if (created + updated + deleted > 0)
                await _db.SaveChangesAsync(ct);

            return new SyncResult(created, updated, deleted, teacherConflicts);
        }

        /// <summary>
        /// Kiểm tra trùng GV theo NGÀY CỤ THỂ (Daily) giữa [start, end).
        /// Chỉ xét các buổi có TeacherId = teacherId. Không còn fallback theo Class.MainTeacherId.
        /// </summary>
        public async Task<bool> CheckTeacherOverlapAsync(int teacherId, int currentClassId, DateOnly date, TimeSpan start, TimeSpan end, int? excludeSessionId, CancellationToken ct)
        {
            static bool Overlaps(TimeSpan a1, TimeSpan a2, TimeSpan b1, TimeSpan b2) => a1 < b2 && b1 < a2;

            var q = _db.ClassSessions
                .Where(s => s.SessionDate == date
                            && s.TeacherId == teacherId
                            && (excludeSessionId == null || s.SessionId != excludeSessionId.Value));

            var list = await q.ToListAsync(ct);
            foreach (var x in list)
            {
                // Bỏ qua chính slot hiện tại khi tạo mới trong cùng lớp và cùng start
                if (x.ClassID == currentClassId && excludeSessionId == null && x.StartTime == start) continue;
                if (Overlaps(x.StartTime, x.EndTime, start, end)) return true;
            }
            return false;
        }
    }
}
